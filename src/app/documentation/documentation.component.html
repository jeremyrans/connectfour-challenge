<mat-card>
  <mat-card-title>Documentation</mat-card-title>
  <mat-card-content>
    <h2>Objective</h2>
    <p>
      The objective of this game is to write the best Connect4 algorithm you can. You will do this by implementing the getCode()
      function, which takes in the state of the game and returns an integer representing the column (0 indexed) you wish
      to drop your piece in. The game will repeatedly call your algorithm with the new state of the game until one of the
      following:
    </p>
    <ul>
      <li>a winner is determined</li>
      <li>an invalid move is attempted</li>
      <li>a stalemate is reached</li>
    </ul>

    <h2>State</h2>
    <p>
      The state passed to your function is a 2d array representing the board. The possible state of each cell is the integer 0,
      1 or 2.
    </p>
    <ul>
      <li>0 is an empty cell</li>
      <li>1 is your piece</li>
      <li>2 is your opponent's piece</li>
    </ul>

    <h2>Syntax</h2>
    <p>
      Your code
      <strong>must</strong> be in the following syntax in order to work:
    </p>
    <pre style="border: 1px solid #666; background-color: #EEE; padding: 10px;">
function getMove(state) {{'{'}}
  return 0;  // index of the column to drop a piece in
{{'}'}}</pre>
    <p>
      Keep all code in a
      <strong>single function</strong> (inner functions are allowed).
    </p>
    <p>If your code returns an invalid move (like a coordinate already hit, or one outside the board) it will end the game in
      your opponent's favour.</p>
    <p>Logging is available through
      <code>console.log(message)</code>. You can also use
      <code>console.error(message)</code>,
      <code>console.warn(message)</code>, and
      <code>console.debug(message)</code>.</p>
    <p>All built-in game state variables are backed up prior, and restored after, your function runs. This prevents tampering.</p>
  </mat-card-content>
</mat-card>
